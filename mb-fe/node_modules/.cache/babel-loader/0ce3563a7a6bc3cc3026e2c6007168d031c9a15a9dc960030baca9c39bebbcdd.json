{"ast":null,"code":"import { ethers } from 'ethers';\nimport Swal from 'sweetalert2';\nclass MetaMask {\n  constructor() {\n    this.addresses = {\n      market: '',\n      token: ''\n    };\n    this.instance = MetaMask.instance();\n  }\n  static isInstalled() {\n    return window && typeof window.ethereum !== 'undefined';\n  }\n  static instance() {\n    if (this.isInstalled()) {\n      return window.ethereum;\n    }\n    Swal.fire({\n      title: 'Oops!',\n      html: `Please install <strong>MetaMask</strong> extension to use this feature.`,\n      confirmButtonText: 'Install',\n      icon: 'error'\n    }).then(answer => {\n      if (answer.value) {\n        var _process$env$METAMASK;\n        window.location.href = (_process$env$METAMASK = process.env.METAMASK_CHROME_LINK) !== null && _process$env$METAMASK !== void 0 ? _process$env$METAMASK : 'https://metamask.io';\n      }\n    });\n    throw new Error('Please install MetaMask extension to use this feature.');\n  }\n  static target() {\n    return typeof window.MetaMaskTarget !== 'undefined' ? window.MetaMaskTarget : window.MetaMaskTarget = new EventTarget();\n  }\n  async initialize() {\n    if (!MetaMask.isInstalled()) {\n      throw new Error('Metamask is not yet installed.');\n    }\n    try {\n      this.provider = new ethers.providers.Web3Provider(window.ethereum);\n      const {\n        chainId\n      } = await this.provider.getNetwork();\n      this.network = chainId;\n      // let accounts = await this.provider.send('eth_requestAccounts', []);\n\n      this.signer = this.provider.getSigner();\n    } catch (error) {\n      throw new Error(error);\n    }\n    return new Promise((resolve, reject) => {\n      resolve({\n        currentAddress: MetaMask.instance().selectedAddress,\n        signer: this.signer\n      });\n    });\n  }\n}\nexport default MetaMask;","map":{"version":3,"names":["ethers","Swal","MetaMask","constructor","addresses","market","token","instance","isInstalled","window","ethereum","fire","title","html","confirmButtonText","icon","then","answer","value","_process$env$METAMASK","location","href","process","env","METAMASK_CHROME_LINK","Error","target","MetaMaskTarget","EventTarget","initialize","provider","providers","Web3Provider","chainId","getNetwork","network","signer","getSigner","error","Promise","resolve","reject","currentAddress","selectedAddress"],"sources":["/home/ha/Downloads/programs/27-10/mb_NFT/mb-fe/src/services/MetaMask.js"],"sourcesContent":["import { ethers } from 'ethers';\nimport Swal from 'sweetalert2';\n\nclass MetaMask {\n    instance;\n    provider;\n    signer;\n\n    addresses = { market: '', token: '' };\n    network;\n    balance;\n\n    constructor() {\n      this.instance = MetaMask.instance();\n    }\n\n    static isInstalled() {\n      return window && typeof window.ethereum !== 'undefined';\n    }\n\n    static instance() {\n      if (this.isInstalled()) {\n        return window.ethereum;\n      }\n      Swal.fire({\n        title: 'Oops!',\n        html: `Please install <strong>MetaMask</strong> extension to use this feature.`,\n        confirmButtonText: 'Install',\n        icon: 'error'\n      }).then((answer) => {\n        if (answer.value) {\n          window.location.href = process.env.METAMASK_CHROME_LINK ?? 'https://metamask.io';\n        }\n      });\n      throw new Error('Please install MetaMask extension to use this feature.');\n    }\n\n    static target() {\n      return typeof window.MetaMaskTarget !== 'undefined'\n        ? window.MetaMaskTarget\n        : (window.MetaMaskTarget = new EventTarget());\n    }\n\n    async initialize() {\n      if (!MetaMask.isInstalled()) {\n          throw new Error('Metamask is not yet installed.');\n      }\n\n      try {\n        this.provider = new ethers.providers.Web3Provider(window.ethereum);\n        const { chainId } = await this.provider.getNetwork();\n        this.network = chainId;\n        // let accounts = await this.provider.send('eth_requestAccounts', []);\n     \n        this.signer = this.provider.getSigner();\n      } catch (error) {\n          throw new Error(error);\n      }\n\n      return new Promise((resolve, reject) => {\n          resolve({\n              currentAddress: MetaMask.instance().selectedAddress,\n              signer: this.signer,\n          });\n      });\n    }\n}\n\nexport default MetaMask;\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,QAAQ;AAC/B,OAAOC,IAAI,MAAM,aAAa;AAE9B,MAAMC,QAAQ,CAAC;EASXC,WAAWA,CAAA,EAAG;IAAA,KAJdC,SAAS,GAAG;MAAEC,MAAM,EAAE,EAAE;MAAEC,KAAK,EAAE;IAAG,CAAC;IAKnC,IAAI,CAACC,QAAQ,GAAGL,QAAQ,CAACK,QAAQ,CAAC,CAAC;EACrC;EAEA,OAAOC,WAAWA,CAAA,EAAG;IACnB,OAAOC,MAAM,IAAI,OAAOA,MAAM,CAACC,QAAQ,KAAK,WAAW;EACzD;EAEA,OAAOH,QAAQA,CAAA,EAAG;IAChB,IAAI,IAAI,CAACC,WAAW,CAAC,CAAC,EAAE;MACtB,OAAOC,MAAM,CAACC,QAAQ;IACxB;IACAT,IAAI,CAACU,IAAI,CAAC;MACRC,KAAK,EAAE,OAAO;MACdC,IAAI,EAAG,yEAAwE;MAC/EC,iBAAiB,EAAE,SAAS;MAC5BC,IAAI,EAAE;IACR,CAAC,CAAC,CAACC,IAAI,CAAEC,MAAM,IAAK;MAClB,IAAIA,MAAM,CAACC,KAAK,EAAE;QAAA,IAAAC,qBAAA;QAChBV,MAAM,CAACW,QAAQ,CAACC,IAAI,IAAAF,qBAAA,GAAGG,OAAO,CAACC,GAAG,CAACC,oBAAoB,cAAAL,qBAAA,cAAAA,qBAAA,GAAI,qBAAqB;MAClF;IACF,CAAC,CAAC;IACF,MAAM,IAAIM,KAAK,CAAC,wDAAwD,CAAC;EAC3E;EAEA,OAAOC,MAAMA,CAAA,EAAG;IACd,OAAO,OAAOjB,MAAM,CAACkB,cAAc,KAAK,WAAW,GAC/ClB,MAAM,CAACkB,cAAc,GACpBlB,MAAM,CAACkB,cAAc,GAAG,IAAIC,WAAW,CAAC,CAAE;EACjD;EAEA,MAAMC,UAAUA,CAAA,EAAG;IACjB,IAAI,CAAC3B,QAAQ,CAACM,WAAW,CAAC,CAAC,EAAE;MACzB,MAAM,IAAIiB,KAAK,CAAC,gCAAgC,CAAC;IACrD;IAEA,IAAI;MACF,IAAI,CAACK,QAAQ,GAAG,IAAI9B,MAAM,CAAC+B,SAAS,CAACC,YAAY,CAACvB,MAAM,CAACC,QAAQ,CAAC;MAClE,MAAM;QAAEuB;MAAQ,CAAC,GAAG,MAAM,IAAI,CAACH,QAAQ,CAACI,UAAU,CAAC,CAAC;MACpD,IAAI,CAACC,OAAO,GAAGF,OAAO;MACtB;;MAEA,IAAI,CAACG,MAAM,GAAG,IAAI,CAACN,QAAQ,CAACO,SAAS,CAAC,CAAC;IACzC,CAAC,CAAC,OAAOC,KAAK,EAAE;MACZ,MAAM,IAAIb,KAAK,CAACa,KAAK,CAAC;IAC1B;IAEA,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACpCD,OAAO,CAAC;QACJE,cAAc,EAAExC,QAAQ,CAACK,QAAQ,CAAC,CAAC,CAACoC,eAAe;QACnDP,MAAM,EAAE,IAAI,CAACA;MACjB,CAAC,CAAC;IACN,CAAC,CAAC;EACJ;AACJ;AAEA,eAAelC,QAAQ"},"metadata":{},"sourceType":"module","externalDependencies":[]}